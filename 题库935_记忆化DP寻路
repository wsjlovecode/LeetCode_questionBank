国际象棋中的骑士可以按下图所示进行移动：

 .           


这一次，我们将 “骑士” 放在电话拨号盘的任意数字键（如上图所示）上，接下来，骑士将会跳 N-1 步。每一步必须是从一个数字键跳到另一个数字键。

每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下 N 位数字。

你能用这种方式拨出多少个不同的号码？

因为答案可能很大，所以输出答案模 10^9 + 7。

 

示例 1：

输入：1
输出：10

示例 2：

输入：2
输出：20

示例 3：

输入：3
输出：46


这道题同样用到了记忆化DP的思想，与之前那些寻路算法有着同样的思想
题解：
class Solution:
    def knightDialer(self, N: int) -> int:
        MOD = 10**9+7
        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]                            #为了解题方便，特地将每个节点对应能到达的节点都列出

        dp = [1]*10
        for hops in range(N-1):
            dp2 = [0]*10
            for node, count in enumerate(dp):
                for i in moves[node]:
                    dp2[i] += count
                    dp2[i] %= MOD
            dp = dp2

        return sum(dp) % MOD       
